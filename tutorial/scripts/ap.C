double APSpline(double x) {
   const int fNp = 46, fKstep = 0;
   const double fDelta = -1, fXmin = 0, fXmax = 1.31943e+06;
   const double fX[46] = { 0, 4685.33, 8260.23, 12834.3, 18400.9,
                        24951.6, 32477, 40965.8, 50405.6, 60782.5,
                        71547.8, 83710.8, 96761.7, 110681, 125449,
                        140317, 156679, 173025, 190889, 208622,
                        227886, 246906, 267463, 287662, 308396,
                        329638, 351358, 374594, 397203, 442434,
                        490059, 537568, 585837, 634618, 683663,
                        731526, 776794, 825182, 869399, 926321,
                        978168, 1.03012e+06, 1.07858e+06, 1.12337e+06, 1.23826e+06,
                        1.31943e+06 };
   const double fY[46] = { 0, 0.507, 0.613, 0.707, 0.807,
                        0.893, 0.993, 0.968, 0.782, 0.451,
                        0.044, -0.336, -0.425, -0.13, 0.435,
                        0.868, 0.96, 0.843, 0.653, 0.451,
                        0.294, 0.087, -0.154, -0.348, -0.579,
                        -0.87, -0.996, -0.922, -0.65, -0.073,
                        0.29, 0.427, 0.436, 0.54, 0.621,
                        0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0,
                        0 };
   const double fB[46] = { 0.00018479, 4.97923e-05, 2.00837e-05, 2.01969e-05, 1.49287e-05,
                        1.40453e-05, 7.59933e-06, -1.20526e-05, -2.6476e-05, -3.62632e-05,
                        -3.74608e-05, -2.1331e-05, 7.60634e-06, 3.3072e-05, 3.78413e-05,
                        1.77495e-05, -3.19116e-06, -9.59402e-06, -1.17299e-05, -9.57709e-06,
                        -8.86862e-06, -1.20845e-05, -1.05826e-05, -9.53473e-06, -1.34926e-05,
                        -1.09412e-05, -1.3737e-06, 8.32765e-06, 1.38639e-05, 1.06157e-05,
                        4.97763e-06, 9.85261e-07, 3.18984e-07, 4.68271e-06, -7.71709e-06,
                        -8.16235e-06, 2.24932e-06, -5.82356e-07, 1.73602e-07, -4.44908e-08,
                        1.1905e-08, -3.08542e-09, 8.22593e-10, -3.14182e-10, 1.30072e-10,
                        -2.21968e-10 };
   const double fC[46] = { -2.02212e-08, -8.59176e-09, 2.81446e-10, -2.56703e-10, -6.89695e-10,
                        5.54837e-10, -1.4114e-09, -9.0363e-10, -6.24302e-10, -3.18876e-10,
                        2.07638e-10, 1.1185e-09, 1.09877e-09, 7.30706e-10, -4.07752e-10,
                        -9.43611e-10, -3.36242e-10, -5.54577e-11, -6.41118e-11, 1.85517e-10,
                        -1.48741e-10, -2.03432e-11, 9.34035e-11, -4.15275e-11, -1.49356e-10,
                        2.69469e-10, 1.71018e-10, 2.46492e-10, -1.62062e-12, -7.01932e-11,
                        -4.81907e-11, -3.58439e-11, 2.20404e-11, 6.74138e-11, -3.20239e-10,
                        3.10936e-10, -8.09343e-11, 2.24146e-11, -5.31809e-12, 1.48662e-12,
                        -3.98884e-13, 1.10365e-13, -2.97201e-14, 4.33697e-15, -4.70323e-16,
                        81172 };
   const double fD[46] = { 8.27362e-13, 8.27362e-13, -3.92173e-14, -2.59283e-14, 6.33275e-14,
                        -8.7094e-14, 1.99388e-14, 9.86345e-15, 9.81113e-15, 1.63028e-14,
                        2.49626e-14, -5.03868e-16, -8.81396e-15, -2.56967e-14, -1.20138e-14,
                        1.23738e-14, 5.72572e-15, -1.61484e-16, 4.69239e-15, -5.7836e-15,
                        2.25028e-15, 1.84437e-15, -2.22669e-15, -1.73351e-15, 6.57245e-15,
                        -1.5109e-15, 1.08271e-15, -3.65805e-15, -5.0535e-16, 1.53997e-16,
                        8.66285e-17, 3.99736e-16, 3.10044e-16, -2.63467e-15, 4.39574e-15,
                        -2.88557e-15, 7.11941e-16, -2.09064e-16, 3.98485e-17, -1.21223e-17,
                        3.26717e-18, -9.6358e-19, 2.53488e-19, -1.3947e-20, -1.3947e-20,
                        55532.1 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}
